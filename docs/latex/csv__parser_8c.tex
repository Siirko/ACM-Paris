\hypertarget{csv__parser_8c}{}\doxysection{src/csv\+\_\+parser.c File Reference}
\label{csv__parser_8c}\index{src/csv\_parser.c@{src/csv\_parser.c}}
{\ttfamily \#include $<$stdio.\+h$>$}\newline
{\ttfamily \#include $<$stdlib.\+h$>$}\newline
{\ttfamily \#include $<$string.\+h$>$}\newline
{\ttfamily \#include \char`\"{}../include/cprintf.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}../include/csv\+\_\+parser.\+h\char`\"{}}\newline
Include dependency graph for csv\+\_\+parser.\+c\+:
% FIG 0
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
int \mbox{\hyperlink{csv__parser_8c_a6bc0f81692cf5d8b837380bbb96b82f4}{size\+\_\+column}} (FILE $\ast$fp, char delimiter)
\item 
char $\ast$$\ast$ \mbox{\hyperlink{csv__parser_8c_a97192f08585d44747acd721a61839330}{get\+\_\+line}} (FILE $\ast$fp, int n, char delimiter)
\item 
void \mbox{\hyperlink{csv__parser_8c_ae7506788e4849e1aa04f5a075d67a9bd}{print\+\_\+line}} (char $\ast$$\ast$line\+\_\+splitted, int n)
\item 
char $\ast$$\ast$ \mbox{\hyperlink{csv__parser_8c_a3ee98b926b3742d7dc82faa3ad514e5b}{split\+\_\+line}} (char $\ast$line, char $\ast$delimiter, int n)
\item 
void \mbox{\hyperlink{csv__parser_8c_a128a04a2edc9c702b876cb1d8c23f74e}{skip\+\_\+header}} (FILE $\ast$fp)
\item 
void \mbox{\hyperlink{csv__parser_8c_a81b03303498e5ea89a90f90da6bc69a2}{exterminate\+\_\+malloc}} (char $\ast$$\ast$rip, int n)
\end{DoxyCompactItemize}


\doxysubsection{Function Documentation}
\mbox{\Hypertarget{csv__parser_8c_a81b03303498e5ea89a90f90da6bc69a2}\label{csv__parser_8c_a81b03303498e5ea89a90f90da6bc69a2}} 
\index{csv\_parser.c@{csv\_parser.c}!exterminate\_malloc@{exterminate\_malloc}}
\index{exterminate\_malloc@{exterminate\_malloc}!csv\_parser.c@{csv\_parser.c}}
\doxysubsubsection{\texorpdfstring{exterminate\_malloc()}{exterminate\_malloc()}}
{\footnotesize\ttfamily void exterminate\+\_\+malloc (\begin{DoxyParamCaption}\item[{char $\ast$$\ast$}]{rip,  }\item[{int}]{n }\end{DoxyParamCaption})}

Free the memory allocated by get\+\_\+line 
\begin{DoxyParams}{Parameters}
{\em rip} & \\
\hline
{\em n} & \\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{80                                           \{}
\DoxyCodeLine{81     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < n; i++)\{}
\DoxyCodeLine{82         free(rip[i]);}
\DoxyCodeLine{83     \}}
\DoxyCodeLine{84     free(rip);}
\DoxyCodeLine{85 \}}

\end{DoxyCode}
\mbox{\Hypertarget{csv__parser_8c_a97192f08585d44747acd721a61839330}\label{csv__parser_8c_a97192f08585d44747acd721a61839330}} 
\index{csv\_parser.c@{csv\_parser.c}!get\_line@{get\_line}}
\index{get\_line@{get\_line}!csv\_parser.c@{csv\_parser.c}}
\doxysubsubsection{\texorpdfstring{get\_line()}{get\_line()}}
{\footnotesize\ttfamily char$\ast$$\ast$ get\+\_\+line (\begin{DoxyParamCaption}\item[{FILE $\ast$}]{fp,  }\item[{int}]{n,  }\item[{char}]{delimiter }\end{DoxyParamCaption})}

Get the line of fp, splitted into an array of strings 
\begin{DoxyParams}{Parameters}
{\em fp} & \\
\hline
{\em n} & \\
\hline
{\em delimiter} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
array of strings 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
delimiter is by default \textquotesingle{};\textquotesingle{} 
\end{DoxyNote}

\begin{DoxyCode}{0}
\DoxyCodeLine{25                                                 \{}
\DoxyCodeLine{26     \textcolor{keywordtype}{char}* buf = malloc(\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{char}) * 1000);}
\DoxyCodeLine{27     \textcolor{keywordflow}{if}(fgets(buf, 1000, fp) == NULL)\{ }
\DoxyCodeLine{28         free(buf); }
\DoxyCodeLine{29         \textcolor{keywordflow}{return} NULL; }
\DoxyCodeLine{30     \}}
\DoxyCodeLine{31     \textcolor{keywordtype}{char} delim[2];}
\DoxyCodeLine{32     delim[0] = delimiter;}
\DoxyCodeLine{33     delim[1] = \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{34     \textcolor{keywordtype}{char}** line\_splitted = \mbox{\hyperlink{csv__parser_8c_a3ee98b926b3742d7dc82faa3ad514e5b}{split\_line}}(buf, delim, n);}
\DoxyCodeLine{35     \textcolor{keywordflow}{if}(line\_splitted == NULL)\{ free(buf); printf(\textcolor{stringliteral}{"{}malloc failed in access\_content.\(\backslash\)n"{}}); exit(1); \}}
\DoxyCodeLine{36 }
\DoxyCodeLine{37     free(buf);}
\DoxyCodeLine{38     \textcolor{keywordflow}{return} line\_splitted;}
\DoxyCodeLine{39 \}}

\end{DoxyCode}
\mbox{\Hypertarget{csv__parser_8c_ae7506788e4849e1aa04f5a075d67a9bd}\label{csv__parser_8c_ae7506788e4849e1aa04f5a075d67a9bd}} 
\index{csv\_parser.c@{csv\_parser.c}!print\_line@{print\_line}}
\index{print\_line@{print\_line}!csv\_parser.c@{csv\_parser.c}}
\doxysubsubsection{\texorpdfstring{print\_line()}{print\_line()}}
{\footnotesize\ttfamily void print\+\_\+line (\begin{DoxyParamCaption}\item[{char $\ast$$\ast$}]{line\+\_\+splitted,  }\item[{int}]{n }\end{DoxyParamCaption})}

Print the content of a line that was been sliced 
\begin{DoxyParams}{Parameters}
{\em line\+\_\+splitted} & \\
\hline
{\em n} & (size of line\+\_\+splitted) \\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{41                                             \{}
\DoxyCodeLine{42 }
\DoxyCodeLine{43     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < n; i++)\{}
\DoxyCodeLine{44         printf(\textcolor{stringliteral}{"{}\%s "{}}, line\_splitted[i]);}
\DoxyCodeLine{45     \}}
\DoxyCodeLine{46     printf(\textcolor{stringliteral}{"{}\(\backslash\)n"{}});}
\DoxyCodeLine{47 \}}

\end{DoxyCode}
\mbox{\Hypertarget{csv__parser_8c_a6bc0f81692cf5d8b837380bbb96b82f4}\label{csv__parser_8c_a6bc0f81692cf5d8b837380bbb96b82f4}} 
\index{csv\_parser.c@{csv\_parser.c}!size\_column@{size\_column}}
\index{size\_column@{size\_column}!csv\_parser.c@{csv\_parser.c}}
\doxysubsubsection{\texorpdfstring{size\_column()}{size\_column()}}
{\footnotesize\ttfamily int size\+\_\+column (\begin{DoxyParamCaption}\item[{FILE $\ast$}]{fp,  }\item[{char}]{delimiter }\end{DoxyParamCaption})}

Get the number of column by counting how many delimiter have the header 
\begin{DoxyParams}{Parameters}
{\em fp} & \\
\hline
{\em delimiter} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
number of column 
\end{DoxyReturn}

\begin{DoxyCode}{0}
\DoxyCodeLine{7                                          \{}
\DoxyCodeLine{8     fseek(fp, 0, SEEK\_SET);}
\DoxyCodeLine{9     \textcolor{keywordtype}{int} c = EOF;}
\DoxyCodeLine{10     \textcolor{keywordtype}{int} counter = 0;}
\DoxyCodeLine{11     \textcolor{keywordflow}{while} ((c=fgetc(fp)) != EOF) \{}
\DoxyCodeLine{12         \textcolor{keywordflow}{if} (c==\textcolor{charliteral}{'\(\backslash\)n'})\{}
\DoxyCodeLine{13             \textcolor{keywordflow}{break};}
\DoxyCodeLine{14         \}}
\DoxyCodeLine{15         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (c == delimiter)\{}
\DoxyCodeLine{16             counter++;}
\DoxyCodeLine{17         \}}
\DoxyCodeLine{18     \}}
\DoxyCodeLine{19     \textcolor{comment}{// Important}}
\DoxyCodeLine{20     \textcolor{keywordflow}{if}((counter == 0 \&\& feof(fp)))\{ \textcolor{keywordflow}{return} 0; \}}
\DoxyCodeLine{21     \textcolor{keywordflow}{return} counter + 1;}
\DoxyCodeLine{22 \}}

\end{DoxyCode}
\mbox{\Hypertarget{csv__parser_8c_a128a04a2edc9c702b876cb1d8c23f74e}\label{csv__parser_8c_a128a04a2edc9c702b876cb1d8c23f74e}} 
\index{csv\_parser.c@{csv\_parser.c}!skip\_header@{skip\_header}}
\index{skip\_header@{skip\_header}!csv\_parser.c@{csv\_parser.c}}
\doxysubsubsection{\texorpdfstring{skip\_header()}{skip\_header()}}
{\footnotesize\ttfamily void skip\+\_\+header (\begin{DoxyParamCaption}\item[{FILE $\ast$}]{fp }\end{DoxyParamCaption})}

Skip the header of the file 
\begin{DoxyParams}{Parameters}
{\em fp} & \\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{71                           \{}
\DoxyCodeLine{72     fseek(fp, 0, SEEK\_SET);}
\DoxyCodeLine{73     \textcolor{keywordtype}{int} c = EOF;}
\DoxyCodeLine{74     \textcolor{keywordflow}{while} ((c=fgetc(fp)) != EOF) \{}
\DoxyCodeLine{75         \textcolor{keywordflow}{if} (c==\textcolor{charliteral}{'\(\backslash\)n'})}
\DoxyCodeLine{76             \textcolor{keywordflow}{break};}
\DoxyCodeLine{77     \}}
\DoxyCodeLine{78 \}}

\end{DoxyCode}
\mbox{\Hypertarget{csv__parser_8c_a3ee98b926b3742d7dc82faa3ad514e5b}\label{csv__parser_8c_a3ee98b926b3742d7dc82faa3ad514e5b}} 
\index{csv\_parser.c@{csv\_parser.c}!split\_line@{split\_line}}
\index{split\_line@{split\_line}!csv\_parser.c@{csv\_parser.c}}
\doxysubsubsection{\texorpdfstring{split\_line()}{split\_line()}}
{\footnotesize\ttfamily char$\ast$$\ast$ split\+\_\+line (\begin{DoxyParamCaption}\item[{char $\ast$}]{line,  }\item[{char $\ast$}]{delimiter,  }\item[{int}]{n }\end{DoxyParamCaption})}

Split the line into an array 
\begin{DoxyParams}{Parameters}
{\em line} & \\
\hline
{\em delimiter} & \\
\hline
{\em n} & (size) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
array of strings 
\end{DoxyReturn}

\begin{DoxyCode}{0}
\DoxyCodeLine{49                                                      \{}
\DoxyCodeLine{50     \textcolor{keywordtype}{char}** spl = (\textcolor{keywordtype}{char}**)malloc(\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{char}*) * (n));}
\DoxyCodeLine{51     \textcolor{keywordflow}{if}(spl == NULL)\{ fprintf(stderr, \textcolor{stringliteral}{"{}malloc failed in split\_line.\(\backslash\)n"{}}); exit(1); \}}
\DoxyCodeLine{52     \textcolor{keywordtype}{char}* str;}
\DoxyCodeLine{53     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < n; i++)\{}
\DoxyCodeLine{54         str = strsep(\&line, delimiter);}
\DoxyCodeLine{55         \textcolor{keywordflow}{if}(str == NULL \&\& i < n)\{ }
\DoxyCodeLine{56             \mbox{\hyperlink{cprintf_8c_abaf6f449289ba2ab499573103e32ec2d}{eprintf}}(\textcolor{stringliteral}{"{}strsep failed in split\_line.\(\backslash\)n"{}}); }
\DoxyCodeLine{57             exit(1); }
\DoxyCodeLine{58         \}}
\DoxyCodeLine{59         \textcolor{comment}{// if it finds a string with no data}}
\DoxyCodeLine{60         \textcolor{comment}{// put NODATA instead}}
\DoxyCodeLine{61         \textcolor{keywordflow}{if}(!strcmp(str, \textcolor{stringliteral}{"{}"{}}))\{}
\DoxyCodeLine{62             spl[i] = strdup(\textcolor{stringliteral}{"{}NODATA"{}});}
\DoxyCodeLine{63         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{64             spl[i] = strdup(str);}
\DoxyCodeLine{65         \}}
\DoxyCodeLine{66     \}}
\DoxyCodeLine{67     \textcolor{keywordflow}{return} spl;}
\DoxyCodeLine{68 \}}

\end{DoxyCode}
